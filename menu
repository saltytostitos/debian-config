#!/usr/bin/env node

const readline = require('readline');
const { spawn } = require('child_process');

// Utility helpers
function stripAnsi(text) {
  return text.replace(/\x1b\[[0-9;]*m/g, '');
}

function centerText(text, width) {
  const strippedLength = stripAnsi(text).length;
  const remaining = Math.max(0, width - strippedLength);
  const left = Math.floor(remaining / 2);
  const right = Math.ceil(remaining / 2);
  return `${' '.repeat(left)}${text}${' '.repeat(right)}`;
}

function padContent(content, width) {
  const cleanLength = stripAnsi(content).length;
  const padding = Math.max(0, width - cleanLength);
  return content + ' '.repeat(padding);
}

// ANSI escape sequences for terminal control
const TERM_CLEAR = '\x1b[2J\x1b[H';
const TERM_BOLD = '\x1b[1m';
const TERM_RESET = '\x1b[0m';
const TERM_HIDE_CURSOR = '\x1b[?25l';
const TERM_SHOW_CURSOR = '\x1b[?25h';
const TERM_WHITE_FG = '\x1b[97m';
const TERM_MUTED_FG = '\x1b[38;5;245m';
const TERM_PRIMARY_FG = '\x1b[38;5;81m';
const TERM_ACCENT_FG = '\x1b[38;5;213m';
const TERM_SUCCESS_FG = '\x1b[38;5;120m';
const TERM_WARNING_FG = '\x1b[38;5;216m';
const TERM_ERROR_FG = '\x1b[38;5;203m';
const TERM_FRAME_BG = '\x1b[48;5;237m';
const TERM_HIGHLIGHT_BG = '\x1b[48;5;60m';
const TERM_ACCENT_BG = '\x1b[48;5;99m';
const TERM_FADE_FG = '\x1b[38;5;240m';
const TERM_PRESS_FG = '\x1b[38;5;153m';
const FRAME_HORIZONTAL = '─';
const FRAME_VERTICAL = '│';
const FRAME_CORNER_TL = '╭';
const FRAME_CORNER_TR = '╮';
const FRAME_CORNER_BL = '╰';
const FRAME_CORNER_BR = '╯';
const TERM_CLEAR_LINE = '\x1b[2K';
const TERM_MOVE_TO_TOP = '\x1b[H';
const TERM_DIM = '\x1b[2m';

// Clean up terminal state on exit
process.on('exit', () => {
  process.stdout.write(TERM_SHOW_CURSOR);
  process.stdout.write(TERM_CLEAR);
});

process.on('SIGINT', () => {
  process.stdout.write(TERM_SHOW_CURSOR);
  process.stdout.write(TERM_CLEAR);
  process.exit(0);
});

process.on('SIGTERM', () => {
  process.stdout.write(TERM_SHOW_CURSOR);
  process.stdout.write(TERM_CLEAR);
  process.exit(0);
});

// Get terminal dimensions
function getTerminalSize() {
  return {
    cols: process.stdout.columns || 80,
    lines: process.stdout.rows || 24
  };
}

// Prompts for arguments
async function moreArgs(args) {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });

  const allArguments = [];

  for (const arg of args) {
    const input = await new Promise(resolve => {
      process.stdout.write(`\n${TERM_ACCENT_FG}${TERM_BOLD}◈${TERM_RESET} ${TERM_PRIMARY_FG}${arg}${TERM_RESET}${TERM_MUTED_FG} — enter value:${TERM_RESET}\n`);
      rl.question(`${TERM_DIM}${TERM_MUTED_FG}${arg}:${TERM_RESET} `, resolve);
    });

    if (arg.includes('-')) {
      allArguments.push(arg);
    }
    allArguments.push(input);

    if (!input.trim()) {
      process.stdout.write(`${TERM_ERROR_FG}${TERM_BOLD}✖${TERM_RESET} ${TERM_ERROR_FG}No arguments were provided for ${arg}${TERM_RESET}\n`);
      await new Promise(resolve => setTimeout(resolve, 2000));
      rl.close();
      return null;
    }
  }

  rl.close();
  return allArguments;
}

// Menu options
const OPTIONS = [
  "Bottom Monitor",
  "htop",
  "Fly.io",
  "Github Clone Repo",
  "mailsy",
  "mkcert",
  "nmap",
  "Pretty Ping",
  "Speed Test",
  "Get Weather",
  "Yazi",
  "Neo VIM",
  "NPM Package Analyzer",
  "Multi Pull",
  "Multi Push",
  "Multi Check",
  "Dev Server Tunnel",
  "Clear DNS",
];

// Function to print the menu
function printMenu(selected, initialized = false) {
  const size = OPTIONS.length;
  const { cols } = getTerminalSize();

  if (!initialized) {
    process.stdout.write(TERM_CLEAR);
  } else {
    process.stdout.write(TERM_MOVE_TO_TOP);
  }

  const frameWidth = Math.min(Math.max(56, Math.floor(cols * 0.62)), cols - 4);
  const padding = Math.max(0, Math.floor((cols - frameWidth) / 2));
  const horizontal = FRAME_HORIZONTAL.repeat(frameWidth - 2);

  const topBorder = `${' '.repeat(padding)}${TERM_FRAME_BG}${FRAME_CORNER_TL}${horizontal}${FRAME_CORNER_TR}${TERM_RESET}`;
  process.stdout.write(`${topBorder}\n`);

  const title = `${TERM_ACCENT_FG}${TERM_BOLD}Command Palette${TERM_RESET}`;
  const subtitle = `${TERM_FADE_FG}${TERM_DIM}Pick something to launch${TERM_RESET}`;
  const hint = `${TERM_FADE_FG}${TERM_DIM}Shift + ↑/↓ jumps faster${TERM_RESET}`;

  process.stdout.write(`${' '.repeat(padding)}${TERM_FRAME_BG}${FRAME_VERTICAL}${padContent(centerText(title, frameWidth - 2), frameWidth - 2)}${FRAME_VERTICAL}${TERM_RESET}\n`);
  process.stdout.write(`${' '.repeat(padding)}${TERM_FRAME_BG}${FRAME_VERTICAL}${padContent(centerText(subtitle, frameWidth - 2), frameWidth - 2)}${FRAME_VERTICAL}${TERM_RESET}\n`);
  process.stdout.write(`${' '.repeat(padding)}${TERM_FRAME_BG}${FRAME_VERTICAL}${padContent(centerText(hint, frameWidth - 2), frameWidth - 2)}${FRAME_VERTICAL}${TERM_RESET}\n`);
  process.stdout.write(`${' '.repeat(padding)}${TERM_FRAME_BG}${FRAME_VERTICAL}${' '.repeat(frameWidth - 2)}${FRAME_VERTICAL}${TERM_RESET}\n`);

  const maxVisible = 11;
  let startIdx = 0;
  let endIdx = size - 1;

  if (size > maxVisible) {
    const halfWindow = Math.floor(maxVisible / 2);
    startIdx = selected - halfWindow;
    endIdx = selected + halfWindow;

    if (startIdx < 0) {
      startIdx = 0;
      endIdx = maxVisible - 1;
    }
    if (endIdx >= size) {
      endIdx = size - 1;
      startIdx = Math.max(0, endIdx - maxVisible + 1);
    }
  }

  if (startIdx > 0) {
    const above = `${TERM_FADE_FG}${TERM_DIM}⋯ more entries above ⋯${TERM_RESET}`;
    process.stdout.write(`${' '.repeat(padding)}${TERM_FRAME_BG}${FRAME_VERTICAL}${padContent(centerText(above, frameWidth - 2), frameWidth - 2)}${FRAME_VERTICAL}${TERM_RESET}\n`);
  }

  for (let i = startIdx; i <= endIdx && i < startIdx + maxVisible; i++) {
    const label = OPTIONS[i];

    if (i === selected) {
      const content = `${TERM_HIGHLIGHT_BG}${TERM_WHITE_FG}${TERM_BOLD}   ➜ ${label}${TERM_RESET}`;
      process.stdout.write(`${' '.repeat(padding)}${TERM_FRAME_BG}${FRAME_VERTICAL}${padContent(content, frameWidth - 2)}${FRAME_VERTICAL}${TERM_RESET}\n`);
    } else {
      const content = `${TERM_FADE_FG}${TERM_DIM}   ${label}${TERM_RESET}`;
      process.stdout.write(`${' '.repeat(padding)}${TERM_FRAME_BG}${FRAME_VERTICAL}${padContent(content, frameWidth - 2)}${FRAME_VERTICAL}${TERM_RESET}\n`);
    }
  }

  if (endIdx < size - 1) {
    const below = `${TERM_FADE_FG}${TERM_DIM}⋯ more entries below ⋯${TERM_RESET}`;
    process.stdout.write(`${' '.repeat(padding)}${TERM_FRAME_BG}${FRAME_VERTICAL}${padContent(centerText(below, frameWidth - 2), frameWidth - 2)}${FRAME_VERTICAL}${TERM_RESET}\n`);
  }

  process.stdout.write(`${' '.repeat(padding)}${TERM_FRAME_BG}${FRAME_VERTICAL}${' '.repeat(frameWidth - 2)}${FRAME_VERTICAL}${TERM_RESET}\n`);

  const footerHelp = `${TERM_FADE_FG}${TERM_DIM}↑/↓ navigate • Enter launch • q quit${TERM_RESET}`;
  process.stdout.write(`${' '.repeat(padding)}${TERM_FRAME_BG}${FRAME_VERTICAL}${padContent(centerText(footerHelp, frameWidth - 2), frameWidth - 2)}${FRAME_VERTICAL}${TERM_RESET}\n`);

  const bottomBorder = `${' '.repeat(padding)}${TERM_FRAME_BG}${FRAME_CORNER_BL}${horizontal}${FRAME_CORNER_BR}${TERM_RESET}`;
  process.stdout.write(`${bottomBorder}\n`);
}

// Function to run selected app



// Function to run selected app
async function runApp(choice) {
  process.stdout.write(TERM_CLEAR);

    const banner = `${TERM_ACCENT_BG}${TERM_WHITE_FG}${TERM_BOLD}  ✷ Launching ${choice} ✷  ${TERM_RESET}`;
  const loading = `${TERM_FADE_FG}${TERM_DIM}Working…${TERM_RESET}`;
  process.stdout.write(`\n${centerText(banner, getTerminalSize().cols)}\n${centerText(loading, getTerminalSize().cols)}\n\n`);

  switch (choice) {
    case "Bottom Monitor": {
      const child = spawn('btm', [], { stdio: 'inherit', env: { ...process.env, TERM: 'xterm-256color' } });
      await waitForChild(child);
      break;
    }

    case "htop": {
      const child = spawn('htop', [], { stdio: 'inherit', env: { ...process.env, TERM: 'xterm-256color' } });
      await waitForChild(child);
      break;
    }

    case "Fly.io": {
      const child = spawn('flyctl', [], { stdio: 'inherit' });
      await waitForChild(child);
      const warning = `${TERM_WARNING_FG}${TERM_BOLD}!${TERM_RESET} ${TERM_WARNING_FG}Not configured — run manually.${TERM_RESET}`;
      process.stdout.write(`\n${centerText(warning, getTerminalSize().cols)}\n`);
      await new Promise(resolve => setTimeout(resolve, 2000));
      break;
    }

    case "Github Clone Repo": {
      const repoArgs = await moreArgs(["REPO_URL"]);
      if (repoArgs) {
        const message = `${TERM_PRIMARY_FG}${TERM_BOLD}→${TERM_RESET} ${TERM_MUTED_FG}Calling: gh repo clone ${repoArgs.join(' ')}${TERM_RESET}`;
        process.stdout.write(`\n${message}\n\n`);
        const child = spawn('gh', ['repo', 'clone', ...repoArgs], { stdio: 'inherit' });
        await waitForChild(child);
        await pauseForUser();
      }
      break;
    }

    case "mailsy": {
      process.stdout.write(`${TERM_CLEAR}${centerText(`${TERM_ACCENT_BG}${TERM_WHITE_FG}${TERM_BOLD}  Mailsy  ${TERM_RESET}`, getTerminalSize().cols)}\n\n`);
      const mailsyOptions = ["Generate", "Fetch", "Delete", "Get Info"];
      mailsyOptions.forEach((opt, index) => {
        process.stdout.write(`${TERM_MUTED_FG}${index + 1}${TERM_RESET} ${opt}\n`);
      });

      const mailsyChoice = await getUserChoice(mailsyOptions.length);
      const commands = {
        "Generate": ['g'],
        "Fetch": ['m'],
        "Delete": ['d'],
        "Get Info": ['me'],
      };

      if (mailsyChoice !== null) {
        const selectedOption = mailsyOptions[mailsyChoice];
        const child = spawn('mailsy', commands[selectedOption], { stdio: 'inherit' });
        await waitForChild(child);
      }

      await pauseForUser();
      break;
    }

    case "mkcert": {
      const hostArgs = await moreArgs(["HOST"]);
      if (hostArgs) {
        const child = spawn('mkcert', hostArgs, { stdio: 'inherit' });
        await waitForChild(child);
        await pauseForUser();
      }
      break;
    }

    case "nmap": {
      const child = spawn('nmap', [], { stdio: 'inherit' });
      await waitForChild(child);
      const warning = `${TERM_WARNING_FG}${TERM_BOLD}!${TERM_RESET} ${TERM_WARNING_FG}Not configured — run manually.${TERM_RESET}`;
      process.stdout.write(`\n${centerText(warning, getTerminalSize().cols)}\n`);
      await new Promise(resolve => setTimeout(resolve, 2000));
      break;
    }

    case "Pretty Ping": {
      const pingArgs = await moreArgs(["HOST"]);
      if (pingArgs) {
        const msg = `${TERM_PRIMARY_FG}→${TERM_RESET} ${TERM_MUTED_FG}Calling: prettyping ${pingArgs.join(' ')}${TERM_RESET}`;
        process.stdout.write(`\n${msg}\n\n`);
        const child = spawn('prettyping', [...pingArgs, '--nounicode', '--nolegend'], { stdio: 'inherit' });
        await waitForChild(child);
        await pauseForUser();
      }
      break;
    }

    case "Speed Test": {
      const child = spawn('speedtest', [], { stdio: 'inherit' });
      await waitForChild(child);
      await pauseForUser();
      break;
    }

    case "Get Weather": {
      const child = spawn('curl', ['https://wttr.in/?QFd'], { stdio: 'inherit' });
      await waitForChild(child);
      await pauseForUser();
      break;
    }

    case "Yazi": {
      const child = spawn('yazi', [], { stdio: 'inherit' });
      await waitForChild(child);
      break;
    }

    case "Neo VIM": {
      const child = spawn('nvim', [], { stdio: 'inherit' });
      await waitForChild(child);
      break;
    }

    case "NPM Package Analyzer": {
      const msg = `${TERM_PRIMARY_FG}→${TERM_RESET} ${TERM_MUTED_FG}Calling: node-modules-inspector${TERM_RESET}`;
      process.stdout.write(`\n${msg}\n\n`);
      const child = spawn('pnpx', ['node-modules-inspector@latest'], { stdio: 'inherit' });
      await waitForChild(child);
      await pauseForUser();
      break;
    }

    case "Multi Pull": {
      const child = spawn('multipull', [], { stdio: 'inherit' });
      await waitForChild(child);
      await pauseForUser();
      break;
    }

    case "Multi Push": {
      const child = spawn('multipush', [], { stdio: 'inherit' });
      await waitForChild(child);
      await pauseForUser();
      break;
    }

    case "Multi Check": {
      const child = spawn('multicheck', [], { stdio: 'inherit' });
      await waitForChild(child);
      await pauseForUser();
      break;
    }

    case "Dev Server Tunnel": {
      const msg = `${TERM_PRIMARY_FG}→${TERM_RESET} ${TERM_MUTED_FG}Calling: dev-tunnel${TERM_RESET}`;
      process.stdout.write(`\n${msg}\n\n`);
      const child = spawn('dev-tunnel', [], { stdio: 'inherit' });
      await waitForChild(child);
      await pauseForUser();
      break;
    }

    case "Clear DNS": {
      const msg = `${TERM_PRIMARY_FG}→${TERM_RESET} ${TERM_MUTED_FG}Calling: cleardns${TERM_RESET}`;
      process.stdout.write(`\n${msg}\n\n`);
      const child = spawn('cleardns', [], { stdio: 'inherit' });
      await waitForChild(child);
      await pauseForUser();
      break;
    }
  }
}

// Helper function to wait for a key press
function waitForKey() {
  return new Promise(resolve => {
    if (process.stdin.isTTY) {
      process.stdin.setRawMode(true);
    }
    process.stdin.resume();
    process.stdin.once('data', () => {
      if (process.stdin.isTTY) {
        process.stdin.setRawMode(false);
      }
      process.stdin.pause();
      resolve();
    });
  });
}

// Helper function to get user choice for numbered options
function getUserChoice(max) {
  return new Promise(resolve => {
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });

    rl.question(`${TERM_DIM}${TERM_MUTED_FG}Choose an option (1-${max}):${TERM_RESET} `, (answer) => {
      rl.close();
      const choice = parseInt(answer, 10) - 1;
      if (choice >= 0 && choice < max) {
        resolve(choice);
      } else {
        resolve(null);
      }
    });
  });
}

// Main function
async function main() {
  let selected = 0;
  const size = OPTIONS.length;
  let initialized = false;

  // Hide cursor
  process.stdout.write(TERM_HIDE_CURSOR);

  // Set up raw mode for key input
  if (process.stdin.isTTY) {
    process.stdin.setRawMode(true);
  }
  process.stdin.resume();
  process.stdin.setEncoding('utf8');

  // Display initial menu
  printMenu(selected, initialized);
  initialized = true;

  // Handle key presses
  process.stdin.on('data', async (key) => {
    // Handle escape sequences for arrow keys
    if (key === '\u001b[A') { // Up arrow
      selected--;
      if (selected < 0) {
        selected = size - 1;
      }
      printMenu(selected, initialized);
    } else if (key === '\u001b[B') { // Down arrow
      selected++;
      if (selected >= size) {
        selected = 0;
      }
      printMenu(selected, initialized);
    } else if (key === '\r' || key === '\n') { // Enter
      process.stdout.write(TERM_SHOW_CURSOR);

      const choice = OPTIONS[selected];
      await runApp(choice);

      initialized = false;
      process.stdout.write(TERM_HIDE_CURSOR);
      printMenu(selected, initialized);
      initialized = true;
    } else if (key === 'q' || key === '\u0003') { // q or Ctrl+C
      process.stdout.write(TERM_SHOW_CURSOR);
      process.stdout.write(TERM_CLEAR);
      process.exit(0);
    }
  });
}

// Start the application
main().catch(console.error);