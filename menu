#!/usr/bin/env node

const chalk = require('chalk');
const readline = require('readline');
const { spawn } = require('child_process');

// ANSI escape sequences for terminal control
const TERM_CLEAR = '\x1b[2J\x1b[H';
const TERM_BOLD = '\x1b[1m';
const TERM_RESET = '\x1b[0m';
const TERM_HIDE_CURSOR = '\x1b[?25l';
const TERM_SHOW_CURSOR = '\x1b[?25h';
const TERM_BLACK_FG = '\x1b[30m';
const TERM_RED_FG = '\x1b[31m';
const TERM_GREEN_FG = '\x1b[32m';
const TERM_YELLOW_FG = '\x1b[33m';
const TERM_BLUE_FG = '\x1b[34m';
const TERM_CYAN_FG = '\x1b[36m';
const TERM_WHITE_FG = '\x1b[37m';
const TERM_WHITE_BG = '\x1b[47m';
const TERM_RED_BG = '\x1b[41m';
const TERM_CYAN_BG = '\x1b[46m';
const TERM_CLEAR_LINE = '\x1b[2K';
const TERM_MOVE_TO_TOP = '\x1b[H';

// Clean up terminal state on exit
process.on('exit', () => {
  process.stdout.write(TERM_SHOW_CURSOR);
  process.stdout.write(TERM_CLEAR);
});

process.on('SIGINT', () => {
  process.stdout.write(TERM_SHOW_CURSOR);
  process.stdout.write(TERM_CLEAR);
  process.exit(0);
});

process.on('SIGTERM', () => {
  process.stdout.write(TERM_SHOW_CURSOR);
  process.stdout.write(TERM_CLEAR);
  process.exit(0);
});

// Get terminal dimensions
function getTerminalSize() {
  return {
    cols: process.stdout.columns || 80,
    lines: process.stdout.rows || 24
  };
}

// Prompts for arguments
async function moreArgs(args) {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });

  const allArguments = [];

  for (const arg of args) {
    const input = await new Promise(resolve => {
      process.stdout.write(`${TERM_BLACK_FG}${TERM_CYAN_BG}Enter value for: ${arg} ${TERM_RESET}\n`);
      rl.question(`${arg}: `, resolve);
    });

    if (arg.includes('-')) {
      allArguments.push(arg);
    }
    allArguments.push(input);

    if (!input.trim()) {
      process.stdout.write(`${TERM_RED_FG}No arguments were provided for ${arg}${TERM_RESET}\n`);
      await new Promise(resolve => setTimeout(resolve, 2000));
      rl.close();
      return null;
    }
  }

  rl.close();
  return allArguments;
}

// Menu options
const OPTIONS = [
  "Bottom Monitor",
  "htop",
  "Fly.io",
  "Github Clone Repo",
  "mailsy",
  "mkcert",
  "nmap",
  "Pretty Ping",
  "Speed Test",
  "Get Weather",
  "Yazi",
  "Neo VIM",
  "NPM Package Analyzer",
  "Multi Pull",
  "Multi Push",
  "Multi Check",
  "Dev Server Tunnel",
  "Clear DNS",
];

// Function to print the menu
function printMenu(selected, initialized = false) {
  const size = OPTIONS.length;
  const { cols } = getTerminalSize();

  if (!initialized) {
    process.stdout.write(TERM_CLEAR);
  } else {
    process.stdout.write(TERM_MOVE_TO_TOP);
  }

  // Print header
  const header = "  Select an app:  ";
  const headerPadding = Math.max(0, Math.floor((cols - header.length) / 2));
  const paddedHeader = ' '.repeat(headerPadding) + header + ' '.repeat(headerPadding);

  process.stdout.write(`${TERM_BOLD}${TERM_WHITE_FG}${TERM_RED_BG}${paddedHeader}${TERM_RESET}\n\n`);

  // Calculate visible range
  const maxVisible = 15;
  let startIdx = 0;
  let endIdx = size - 1;

  if (size > maxVisible) {
    const halfWindow = Math.floor(maxVisible / 2);
    startIdx = selected - halfWindow;
    endIdx = selected + halfWindow;

    if (startIdx < 0) {
      startIdx = 0;
      endIdx = maxVisible - 1;
    }
    if (endIdx >= size) {
      endIdx = size - 1;
      startIdx = Math.max(0, endIdx - maxVisible + 1);
    }
  }

  // Show scroll indicator if needed
  if (startIdx > 0) {
    process.stdout.write(`  ${TERM_WHITE_FG}${TERM_BOLD}↑ More options above ${TERM_RESET}\n`);
  } else {
    process.stdout.write(`${TERM_CLEAR_LINE}\n`);
  }

  // Display menu items
  for (let i = 0; i <= maxVisible + 1; i++) {
    const idx = startIdx + i;
    process.stdout.write(TERM_CLEAR_LINE);

    if (idx >= 0 && idx <= endIdx) {
      if (idx === selected) {
        process.stdout.write(`${TERM_BLACK_FG}${TERM_WHITE_BG}${TERM_BOLD} → ${OPTIONS[idx]} ${TERM_RESET}\n`);
      } else {
        process.stdout.write(`  ${OPTIONS[idx]}\n`);
      }
    } else {
      process.stdout.write('\n');
    }
  }

  // Show scroll indicator if needed
  process.stdout.write(TERM_CLEAR_LINE);
  if (endIdx < size - 1) {
    process.stdout.write(`  ${TERM_WHITE_FG}${TERM_BOLD}↓ More options below ${TERM_RESET}\n`);
  } else {
    process.stdout.write('\n');
  }

  process.stdout.write('\n');
  process.stdout.write(TERM_CLEAR_LINE);
  process.stdout.write(`${TERM_CYAN_FG}${TERM_BOLD}──────────────────────────────────${TERM_RESET}\n`);
  process.stdout.write(TERM_CLEAR_LINE);
  process.stdout.write(`${TERM_YELLOW_FG}Use ${TERM_BOLD}↑/↓${TERM_RESET}${TERM_YELLOW_FG} arrow keys to navigate and ${TERM_BOLD}Enter${TERM_RESET}${TERM_YELLOW_FG} to select. Press ${TERM_BOLD}q${TERM_RESET}${TERM_YELLOW_FG} to quit.${TERM_RESET}\n`);
}

// Function to run selected app
async function runApp(choice) {
  process.stdout.write(TERM_CLEAR);

  switch (choice) {
    case "Bottom Monitor":
      process.stdout.write("Starting Bottom Monitor...\n");
      spawn('btm', [], { stdio: 'inherit', env: { ...process.env, TERM: 'xterm-256color' } });
      break;

    case "htop":
      process.stdout.write("Starting htop...\n");
      spawn('htop', [], { stdio: 'inherit', env: { ...process.env, TERM: 'xterm-256color' } });
      break;

    case "Fly.io":
      spawn('flyctl', [], { stdio: 'inherit' });
      process.stdout.write(`${TERM_RED_FG}NOT CONFIGURED -- MUST USE MANUALLY${TERM_RESET}\n`);
      await new Promise(resolve => setTimeout(resolve, 2000));
      break;

    case "Github Clone Repo":
      const repoArgs = await moreArgs(["REPO_URL"]);
      if (repoArgs) {
        process.stdout.write(`Calling: gh repo clone ${repoArgs.join(' ')}\n`);
        const child = spawn('gh', ['repo', 'clone', ...repoArgs], { stdio: 'inherit' });
        await new Promise(resolve => {
          child.on('close', resolve);
        });
        process.stdout.write("Press any key to continue...");
        await waitForKey();
      }
      break;

    case "mailsy":
      process.stdout.write(`${TERM_CLEAR}${TERM_WHITE_FG}${TERM_CYAN_BG}  Mailsy  ${TERM_RESET}\n`);
      process.stdout.write(`${TERM_YELLOW_FG}Select an option:\n`);

      const mailsyOptions = ["Generate", "Fetch", "Delete", "Get Info"];
      for (let i = 0; i < mailsyOptions.length; i++) {
        process.stdout.write(`${i + 1}) ${mailsyOptions[i]}\n`);
      }

      const mailsyChoice = await getUserChoice(mailsyOptions.length);
      if (mailsyChoice !== null) {
        const selectedOption = mailsyOptions[mailsyChoice];
        switch (selectedOption) {
          case "Generate":
            spawn('mailsy', ['g'], { stdio: 'inherit' });
            break;
          case "Fetch":
            spawn('mailsy', ['m'], { stdio: 'inherit' });
            break;
          case "Delete":
            spawn('mailsy', ['d'], { stdio: 'inherit' });
            break;
          case "Get Info":
            spawn('mailsy', ['me'], { stdio: 'inherit' });
            break;
        }
      }

      process.stdout.write("Press any key to continue...");
      await waitForKey();
      break;

    case "mkcert":
      const hostArgs = await moreArgs(["HOST"]);
      if (hostArgs) {
        process.stdout.write(TERM_CLEAR);
        const child = spawn('mkcert', hostArgs, { stdio: 'inherit' });
        await new Promise(resolve => {
          child.on('close', resolve);
        });
        process.stdout.write("Press any key to continue...");
        await waitForKey();
      }
      break;

    case "nmap":
      spawn('nmap', [], { stdio: 'inherit' });
      process.stdout.write(`${TERM_RED_FG}NOT CONFIGURED -- MUST USE MANUALLY${TERM_RESET}\n`);
      await new Promise(resolve => setTimeout(resolve, 2000));
      break;

    case "Pretty Ping":
      const pingArgs = await moreArgs(["HOST"]);
      if (pingArgs) {
        process.stdout.write(`Calling: prettyping ${pingArgs.join(' ')}\n`);
        const child = spawn('prettyping', [...pingArgs, '--nounicode', '--nolegend'], { stdio: 'inherit' });
        await new Promise(resolve => {
          child.on('close', resolve);
        });
        process.stdout.write("Press any key to continue...");
        await waitForKey();
      }
      break;

    case "Speed Test":
      const speedChild = spawn('speedtest', [], { stdio: 'inherit' });
      await new Promise(resolve => {
        speedChild.on('close', resolve);
      });
      process.stdout.write("Press any key to continue...");
      await waitForKey();
      break;

    case "Get Weather":
      spawn('curl', ['https://wttr.in/?QFd'], { stdio: 'inherit' });
      process.stdout.write("Press any key to continue...");
      await waitForKey();
      break;

    case "Yazi":
      spawn('yazi', [], { stdio: 'inherit' });
      break;

    case "Neo VIM":
      spawn('nvim', [], { stdio: 'inherit' });
      break;

    case "NPM Package Analyzer":
      process.stdout.write("Calling: node-modules-inspector\n");
      spawn('pnpx', ['node-modules-inspector@latest'], { stdio: 'inherit' });
      process.stdout.write("Press any key to continue...");
      await waitForKey();
      break;

    case "Multi Pull":
      const pullChild = spawn('multipull', [], { stdio: 'inherit' });
      await new Promise(resolve => {
        pullChild.on('close', resolve);
      });
      process.stdout.write("Press any key to continue...");
      await waitForKey();
      break;

    case "Multi Push":
      const pushChild = spawn('multipush', [], { stdio: 'inherit' });
      await new Promise(resolve => {
        pushChild.on('close', resolve);
      });
      process.stdout.write("Press any key to continue...");
      await waitForKey();
      break;

    case "Multi Check":
      const checkChild = spawn('multicheck', [], { stdio: 'inherit' });
      await new Promise(resolve => {
        checkChild.on('close', resolve);
      });
      process.stdout.write("Press any key to continue...");
      await waitForKey();
      break;

    case "Dev Server Tunnel":
      process.stdout.write("Calling: dev-tunnel\n");
      const tunnelChild = spawn('dev-tunnel', [], { stdio: 'inherit' });
      await new Promise(resolve => {
        tunnelChild.on('close', resolve);
      });
      process.stdout.write("Press any key to continue...");
      await waitForKey();
      break;

    case "Clear DNS":
      process.stdout.write("Calling: cleardns\n");
      const dnsChild = spawn('cleardns', [], { stdio: 'inherit' });
      await new Promise(resolve => {
        dnsChild.on('close', resolve);
      });
      process.stdout.write("Press any key to continue...");
      await waitForKey();
      break;
  }
}

// Helper function to wait for a key press
function waitForKey() {
  return new Promise(resolve => {
    process.stdin.setRawMode(true);
    process.stdin.resume();
    process.stdin.once('data', () => {
      process.stdin.setRawMode(false);
      process.stdin.pause();
      resolve();
    });
  });
}

// Helper function to get user choice for numbered options
function getUserChoice(max) {
  return new Promise(resolve => {
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });

    rl.question('', (answer) => {
      rl.close();
      const choice = parseInt(answer) - 1;
      if (choice >= 0 && choice < max) {
        resolve(choice);
      } else {
        resolve(null);
      }
    });
  });
}

// Main function
async function main() {
  let selected = 0;
  const size = OPTIONS.length;
  let initialized = false;

  // Hide cursor
  process.stdout.write(TERM_HIDE_CURSOR);

  // Set up raw mode for key input
  if (process.stdin.isTTY) {
    process.stdin.setRawMode(true);
  }
  process.stdin.resume();
  process.stdin.setEncoding('utf8');

  // Display initial menu
  printMenu(selected, initialized);
  initialized = true;

  // Handle key presses
  process.stdin.on('data', async (key) => {
    // Handle escape sequences for arrow keys
    if (key === '\u001b[A') { // Up arrow
      selected--;
      if (selected < 0) {
        selected = size - 1;
      }
      printMenu(selected, initialized);
    } else if (key === '\u001b[B') { // Down arrow
      selected++;
      if (selected >= size) {
        selected = 0;
      }
      printMenu(selected, initialized);
    } else if (key === '\r' || key === '\n') { // Enter
      process.stdout.write(TERM_SHOW_CURSOR);

      const choice = OPTIONS[selected];
      await runApp(choice);

      initialized = false;
      process.stdout.write(TERM_HIDE_CURSOR);
      printMenu(selected, initialized);
      initialized = true;
    } else if (key === 'q' || key === '\u0003') { // q or Ctrl+C
      process.stdout.write(TERM_SHOW_CURSOR);
      process.stdout.write(TERM_CLEAR);
      process.exit(0);
    }
  });
}

// Start the application
main().catch(console.error);